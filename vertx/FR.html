<!DOCTYPE html>
<html lang=FR>
    <head>
        <title> vertx Refcard</title>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
        <link rel='stylesheet' href='../css/refcards-style.css'>
        <script async defer src="https://buttons.github.io/buttons.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ScrollMagic/2.0.8/ScrollMagic.min.js"></script>
    </head>
    <body>
    <div class="first-page" style="background-color: #B236A9">
        <div class="buttons">
            <a href="../index.html">
                <img src="../assets/back-logo.svg" alt="fleche retour">
            </a>
            <a href="https://github.com/ineat/refcards/discussions/new" class="hide_mobile">Une erreur ? Une question ? Éditer cette page sur Github</a>
            <a class="github-button" href="https://github.com/ineat/refcards" data-color-scheme="no-preference: light; light: light; dark: dark;" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star ineat/refcards on GitHub">Star</a>
            <div class="internationalization">
        <img src="../assets/FR.png" alt="FR flag">
            <select onchange="location= this.value">
                <option selected>FR</option>
            </select>
    </div>
        </div>
        <img src="" alt="">
        <div class="band">
            <img src="assets/logo-vertx.png" alt="logo vertx">
            <img src="../assets/ineat-logo.svg" alt="logo ineat">
        </div>
        <a href="https://github.com/ineat/refcards">
            <img src="../assets/github_fabbutton.svg" alt="logo github" id="github">
        </a>
    </div>
    <div class="buttons-on-page">
        <a href="../index.html">
            <img src="../assets/back-logo-black.svg" alt="fleche retour">
        </a>
        <a href="https://github.com/ineat/refcards/discussions/new" class="hide_mobile">Une erreur ? Une question ? Éditer cette page sur Github</a>
        <a class="github-button" href="https://github.com/ineat/refcards" data-color-scheme="no-preference: light; light: light; dark: dark;" data-icon="octicon-star" data-size="large" data-show-count="true" aria-label="Star ineat/refcards on GitHub">Star</a>
        <div class="little-menu">
            <img src="assets/logo-vertx.png" alt="logo vertx">
        </div>
        <div class="internationalization">
        <img src="../assets/FR.png" alt="FR flag">
            <select onchange="location= this.value">
                <option selected>FR</option>
            </select>
    </div>
    </div>
        <h1 class="heading1" style="color: #B236A9" id="vertx-refcard"><a class="anchor" href="#vertx-refcard"><img src="../assets/anchor.svg" alt></a>Vertx RefCard</h1><p><em>Version française</em></p>
<p>RefCard d&#39;utilisation de Vertx 3.8.0</p>
<p>Ecrit par Mathias Deremer-Accettone</p>
</div>

                        <div class="h2-part" id="div-sommaire">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#sommaire"><img src="../assets/anchor.svg" alt></a>Sommaire</h2>

                            <div class="title-menu-container"><p class="title-menu" id="sommaire">Sommaire</p></div>
<ol>
<li><a class="links" style="color :#B236A9" href="#vertx-kesako-" title="">Vertx, kesako ?</a></li>
<li><a class="links" style="color :#B236A9" href="#dfinitions-et-terminologie" title="">Définitions et Terminologie</a></li>
<li><a class="links" style="color :#B236A9" href="#qui-utilise-vertx-" title="">Qui utilise Vertx ?</a></li>
<li><a class="links" style="color :#B236A9" href="#concevoir-des-apis-avec-vertx" title="">Concevoir des APIs avec Vertx</a><ul>
<li><a class="links" style="color :#B236A9" href="#ma-premire-api" title="">Ma première API</a></li>
<li><a class="links" style="color :#B236A9" href="#paramtres-dune-requte" title="">Paramètres d’une requête</a></li>
<li><a class="links" style="color :#B236A9" href="#api-contract---thorie" title="">API Contract - Théorie</a></li>
<li><a class="links" style="color :#B236A9" href="#api-contract---mise-en-pratique" title="">API Contract – Mise en Pratique</a></li>
<li><a class="links" style="color :#B236A9" href="#executer-du-code-bloquant---thorie" title="">Exécuter du code bloquant – Théorie</a></li>
<li><a class="links" style="color :#B236A9" href="#executer-du-code-bloquant---pratique" title="">Executer du code bloquant – Pratique</a></li>
<li><a class="links" style="color :#B236A9" href="#circuit-breaker" title="">Circuit Breaker</a></li>
</ul>
</li>
<li><a class="links" style="color :#B236A9" href="#vertx-pour-le-web" title="">Vertx pour le web</a><ul>
<li><a class="links" style="color :#B236A9" href="#servir-des-pages-web" title="">Servir des pages web</a></li>
<li><a class="links" style="color :#B236A9" href="#stocker-des-donnes---sessions" title="">Stocker des données : sessions</a></li>
<li><a class="links" style="color :#B236A9" href="#stocker-des-donnes---cookies" title="">Stocker des données : cookies</a></li>
<li><a class="links" style="color :#B236A9" href="#saisir-des-donnes--les-formulaires" title="">Saisir des données : les formulaires</a></li>
</ul>
</li>
<li><a class="links" style="color :#B236A9" href="#levent-bus-le-systme-nerveux-de-vertx" title="">L&#39;Event Bus, le système nerveux de Vertx</a><ul>
<li><a class="links" style="color :#B236A9" href="#event-bus---thorie" title="">Event Bus – Théorie</a></li>
<li><a class="links" style="color :#B236A9" href="#event-bus---en-local" title="">Event Bus – En local</a></li>
<li><a class="links" style="color :#B236A9" href="#event-bus--en-cluster" title="">Event Bus – En cluster</a></li>
</ul>
</li>
<li><a class="links" style="color :#B236A9" href="#gerer-efficacement-les-micro-services" title="">Gérer efficacement les micro services</a><ul>
<li><a class="links" style="color :#B236A9" href="#services-discovery---thorie" title="">Service Discovery - Théorie</a></li>
<li><a class="links" style="color :#B236A9" href="#services-discovery---mise-en-pratique" title="">Service Discovery - Mise en pratique</a></li>
</ul>
</li>
<li><a class="links" style="color :#B236A9" href="#tester-lapplication" title="">Tester l&#39;application</a><ul>
<li><a class="links" style="color :#B236A9" href="#les-collections-de-tests-avec-vertx-unit" title="">Les collections de tests avec Vertx Unit</a></li>
<li><a class="links" style="color :#B236A9" href="#chaner-ses-tests-vertx-unit" title="">Chaîner ses tests Vertx Unit</a></li>
</ul>
</li>
<li><a class="links" style="color :#B236A9" href="#dployer-et-administrer" title="">Déployer et Administrer</a><ul>
<li><a class="links" style="color :#B236A9" href="#le-cli-vertx" title="">Le CLI Vertx</a></li>
<li><a class="links" style="color :#B236A9" href="#configurations-et-logs" title="">Configurations et logs</a></li>
<li><a class="links" style="color :#B236A9" href="#dploiement-rapide-de-lapplication" title="">Déploiement rapide de l&#39;application</a></li>
<li><a class="links" style="color :#B236A9" href="#dploiement-avanc-et-scalabilit" title="">Déploiement avancé et scalabilité</a></li>
</ul>
</li>
<li><a class="links" style="color :#B236A9" href="#observabilit" title="">Observabilité</a><ul>
<li><a class="links" style="color :#B236A9" href="#contrler-ltat-dune-application" title="">Contrôler l&#39;état d&#39;une application</a></li>
<li><a class="links" style="color :#B236A9" href="#exposer-des-indicateurs---thorie" title="">Exposer des indicateurs - Théorie</a></li>
<li><a class="links" style="color :#B236A9" href="#exposer-des-indicateurs---mise-en-pratique" title="">Exposer des indicateurs - Mise en pratique</a></li>
</ul>
</li>
<li><a class="links" style="color :#B236A9" href="#references" title="">Conclusion</a></li>
<li><a class="links" style="color :#B236A9" href="#references" title="">Références</a></li>
<li><a class="links" style="color :#B236A9" href="#a-propos-dineat" title="">A propos d&#39;Ineat</a></li>
</ol>
</div>

                        <div class="h2-part" id="div-vertx-kesako-">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#vertx-kesako-"><img src="../assets/anchor.svg" alt></a>Vertx, kesako ?</h2>

                            <div class="title-menu-container"><p class="title-menu" id="vertx-kesako-">Vertx, kesako ?</p></div>
<h3 class="heading3" style="color: #B236A9" id="born-to-be-reactive"><a class="anchor" href="#born-to-be-reactive"><img src="../assets/anchor.svg" alt></a>Born to be reactive</h3><p>Véritable boîte à outils événementielle, Vertx est adapté au développement d’applications qui nécessitent souplesse et performance en remplissant à merveille les 4 critères clé
de l’architecture réactive.</p>
<p><img src="./assets/reactive-system.png" alt="" title=""></p>
<h3 class="heading3" style="color: #B236A9" id="polyglotte"><a class="anchor" href="#polyglotte"><img src="../assets/anchor.svg" alt></a>Polyglotte</h3><p>Un autre aspect intéressant de Vertx : il est polyglotte. Les composants peuvent être développés en Java, Kotlin, Javascript, Ceylon, Groovy, Ruby, Scala.
Vous pouvez vous mettre à vertx ou développer un premier micro service sans quitter votre langage favori, de quoi se mettre le pied à l’étrier et s’approprier les concepts. Par contre petit bémol, n’oubliez pas que seuls les composants Java sont les plus up to date...</p>
<p><img src="./assets/vertx-langage.png" alt="" title=""></p>
</div>

                        <div class="h2-part" id="div-définitions-et-terminologie">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#définitions-et-terminologie"><img src="../assets/anchor.svg" alt></a>Définitions et Terminologie</h2>

                            <div class="title-menu-container"><p class="title-menu" id="définitions-et-terminologie">Définitions et Terminologie</p></div>
<p>Avant toute chose, petit focus sur la terminologie de Vertx.</p>
<h3 class="heading3" style="color: #B236A9" id="verticle"><a class="anchor" href="#verticle"><img src="../assets/anchor.svg" alt></a>Verticle</h3><p>Composant de base déployé et exécuté au sein de toute application Vertx. Un verticle a généralement pour rôle d’exposer des handlers. Une application peut exposer un ou plusieurs verticles qui ont des périmètres techniques ou fonctionnels différents. Soulignons que les verticles peuvent être de différents types : les verticles &quot;classiques&quot; orchestrés par l’Event Loop,
et les workers.
Les workers ont un cycle de vie particulier puisqu’ils sont executés à partir de threads disponibles dans un pool de threads spécifiques et non depuis l’event loop. Ils sont généralement utilisés pour exécuter du code bloquant comme les écritures en base de données s’appuyant sur JDBC.</p>
<h3 class="heading3" style="color: #B236A9" id="handler"><a class="anchor" href="#handler"><img src="../assets/anchor.svg" alt></a>Handler</h3><p>Rappelez-vous Vertx est évènementiel, il va donc falloir traiter ces évènements : c’est le rôle de vos handlers. Requête HTTP ou message, vos traitements devront ne pas être bloquant : &quot;don’t block the event loop&quot; !</p>
<h3 class="heading3" style="color: #B236A9" id="event-loop-boucle-dévénements"><a class="anchor" href="#event-loop-boucle-dévénements"><img src="../assets/anchor.svg" alt></a>Event Loop (Boucle d&#39;événements)</h3><p>L’Event Loop est en charge de la répartition des événements entrants (ex : arrivée d’une requête HTTP) vers le bon Handler, comme le montre le schéma suivant :</p>
<p><img src="./assets/event-loop.png" alt="" title=""></p>
<p>Ce concept est bien connu des développeurs Node.js Cependant contrairement à Node.js, chaque instance Vertx peut maintenir plusieurs instances (threads) d’Event Loop. Par défaut le nombre d’instances correspond au nombre de core multiplié par 2.</p>
</div>

                        <div class="h2-part" id="div-qui-utilise-vertx-">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#qui-utilise-vertx-"><img src="../assets/anchor.svg" alt></a>Qui utilise Vertx ?</h2>

                            <div class="title-menu-container"><p class="title-menu" id="qui-utilise-vertx-">Qui utilise Vertx ?</p></div>
<p>Encore peu répandu il y a quelques années, Vertx bénéficie aujourd’hui d’une communauté conséquente et est utilisé par de nombreuses entreprises. Citons par exemple Michelin avec leur plateforme de collecte de données issues de pneus connectés, Red Hat et son Framework Quarkus qui s’appuie en partie sur Vertx, ou encore la solution d’API Management Gravitee.</p>
<p><img src="./assets/user-vertx.png" alt="" title=""></p>
</div>

                        <div class="h2-part" id="div-concevoir-des-apis-avec-vertx">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#concevoir-des-apis-avec-vertx"><img src="../assets/anchor.svg" alt></a>Concevoir des APIs avec Vertx</h2>

                            <div class="title-menu-container"><p class="title-menu" id="concevoir-des-apis-avec-vertx">Concevoir des APIs avec Vertx</p></div>
<h3 class="heading3" style="color: #B236A9" id="ma-première-api"><a class="anchor" href="#ma-première-api"><img src="../assets/anchor.svg" alt></a>Ma première API</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires"><a class="anchor" href="#dépendances-nécessaires"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><p><img src="./assets/first-api-dependances.png" alt="" title=""></p>
<h4 class="heading4" style="color: #B236A9" id="permier-handler"><a class="anchor" href="#permier-handler"><img src="../assets/anchor.svg" alt></a>Permier handler</h4><p>Définir un handler revient à implémenter l’interface <strong>Handler</strong>. La méthode <strong>handle</strong> est invoquée à chaque déclenchement d’un handler, et prend en paramètre un <strong>RoutingContext</strong> qui va vous permettre d’interagir sur le contexte HTTP.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Handler</span>&lt;<span class="hljs-title">RoutingContext</span>&gt; </span>{       <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(RoutingContext routingContext)</span> </span>{
    routingContext.response().end(<span class="hljs-string">&quot;Hello world !!&quot;</span>); }
  }</code></pre><h4 class="heading4" style="color: #B236A9" id="création-du-verticle-et-déclaration-du-router"><a class="anchor" href="#création-du-verticle-et-déclaration-du-router"><img src="../assets/anchor.svg" alt></a>Création du verticle et déclaration du router</h4><p>Le router permet de déterminer dans quels cas le handler sera invoqué (par méthode HTTP, expressions régulières...).</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloVerticle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractVerticle</span> </span>{ 
  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>{
    Router router = Router.router(vertx); router.get(<span class="hljs-string">&quot;/hello&quot;</span>).handler(<span class="hljs-keyword">new</span> HelloWorldHandler()); vertx.createHttpServer().requestHandler(router).listen(<span class="hljs-number">8080</span>);
  } 
}</code></pre><p>Par définition, un verticle est une classe qui étend <strong>AbstractVerticle</strong>, et dans laquelle est surchargée la méthode <strong>start</strong>. Le <strong>Router</strong> permet d’associer les requêtes d’URL « /hello » et de type <strong>GET</strong> au handler défini précédemment. Un serveur HTTP est ensuite créé et mis en écoute sur le port 8080.</p>
<p><img src="./assets/first-api-schema.png" alt="" title=""></p>
<h3 class="heading3" style="color: #B236A9" id="paramètres-dune-requête"><a class="anchor" href="#paramètres-dune-requête"><img src="../assets/anchor.svg" alt></a>Paramètres d&#39;une requête</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-1"><a class="anchor" href="#dépendances-nécessaires-1"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><p><img src="./assets/query-param-dependances.png" alt="" title=""></p>
<h4 class="heading4" style="color: #B236A9" id="query-params"><a class="anchor" href="#query-params"><img src="../assets/anchor.svg" alt></a>Query params</h4><p>Les Query params sont probablement les plus simples à récupérer, l’accès se faisant au travers d’une Multimap :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">MultiMap parameters = routingContext.request().params()</code></pre><h4 class="heading4" style="color: #B236A9" id="path-params"><a class="anchor" href="#path-params"><img src="../assets/anchor.svg" alt></a>Path params</h4><h5 class="heading5" style="color: #B236A9" id="déclaration"><a class="anchor" href="#déclaration"><img src="../assets/anchor.svg" alt></a>Déclaration</h5><p>Implique la modification de l’url déclarée dans le <strong>Router</strong> en déclarant les paramètres avec <strong>:[nom]</strong></p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">router.delete(<span class="hljs-string">&quot;/example/:id&quot;</span>).handler(<span class="hljs-keyword">new</span> DeleteExampleHandler());</code></pre><h5 class="heading5" style="color: #B236A9" id="récupération"><a class="anchor" href="#récupération"><img src="../assets/anchor.svg" alt></a>Récupération</h5><p>L’accès au paramètre se fait ensuite comme suit côté <strong>Handler</strong> :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">routingContext.request().getParam(<span class="hljs-string">&quot;id&quot;</span>);</code></pre><h4 class="heading4" style="color: #B236A9" id="body-params"><a class="anchor" href="#body-params"><img src="../assets/anchor.svg" alt></a>Body params</h4><h5 class="heading5" style="color: #B236A9" id="déclaration-1"><a class="anchor" href="#déclaration-1"><img src="../assets/anchor.svg" alt></a>Déclaration</h5><p>L’accès au body d’une requête <strong>POST</strong> implique l’ajout d’un <strong>BodyHandler</strong> au router (côté verticle).</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">router.route().handler(BodyHandler.create()); 
router.post(<span class="hljs-string">&quot;/example&quot;</span>).handler(<span class="hljs-keyword">new</span> PosExampletHandler());</code></pre><h5 class="heading5" style="color: #B236A9" id="récupération-1"><a class="anchor" href="#récupération-1"><img src="../assets/anchor.svg" alt></a>Récupération</h5><p>Côté <strong>Handler</strong> l’accès au body se fera via <strong>RoutingContext</strong>.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">JsonObject jsonObject = routingContext.getBodyAsJson(); 
JsonArray jsonArray = routingContext.getBodyAsJsonArray(); 
Buffer buffer = routingContext.getBody();
String body = routingContext.getBodyAsString();</code></pre><h3 class="heading3" style="color: #B236A9" id="api-contract---théorie"><a class="anchor" href="#api-contract---théorie"><img src="../assets/anchor.svg" alt></a>API Contract - Théorie</h3><p>Lorsqu’on conçoit des APIs on a parfois l’habitude de rédiger du code et d’en générer la documentation (<strong>Swagger</strong> ou <strong>OpenApi</strong>). Comme vu précédemment, créer rapidement des routes et y associer des <strong>handlers</strong> est très simple, la documentation pouvant être écrite dans un second temps. Mais <strong>Vertx</strong> offre également une autre approche grâce à l’<strong>API Contract</strong> : ici on écrit la <strong>SwaggerDoc</strong> qui contiendra les spécificités de nos APIs, puis on passe au code. Ce mécanisme repose sur l’utilisation de la classe <strong>OpenAPI3RouterFactory</strong>, dont la fonction est de générer un router à partir du fichier YAML contenant la documentation (et donc les routes de nos APIs). </p>
<p>Cependant <strong>API Contract</strong> ne se limite pas uniquement à cela puisqu’il permet, entre-autre, de générer automatiquement les <strong>handlers</strong> de validation : si une requête entrante ne respecte pas le format spécifié dans la documentation, une erreur 400 sera alors renvoyée à l’appelant.</p>
<p>La contrainte (qui n’en est finalement pas une) est bien évidemment d’avoir une documentation rigoureusement maintenue, et les avantages sont nombreux : moins de code à écrire, <strong>BodyHandler</strong> généré automatiquement pour les requêtes POST, davantage de contrôles
sur les requêtes entrantes, ...</p>
<p><img src="./assets/api-contract-schema.png" alt="" title=""></p>
<p>1 -    La <strong>RouterFactory</strong> analyse le fichier <strong>Swagger</strong>.</p>
<p>2 -    Un <strong>Router</strong> est généré par la <strong>RouterFactory</strong> à partir du contenu de la <strong>SwaggerDoc</strong>.</p>
<p>3 -    Les routes correspondant aux <strong>endpoints</strong> spécifiés dans la <strong>SwaggerDoc</strong> sont exposées et liées aux handlers (<strong>BodyHandler</strong> et <strong>ValidationHandler</strong> étant automatiquement générés).</p>
<h3 class="heading3" style="color: #B236A9" id="api-contract---mise-en-pratique"><a class="anchor" href="#api-contract---mise-en-pratique"><img src="../assets/anchor.svg" alt></a>API Contract - Mise en pratique</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-2"><a class="anchor" href="#dépendances-nécessaires-2"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><p><img src="./assets/api-contract-dependances.png" alt="" title=""></p>
<h4 class="heading4" style="color: #B236A9" id="la-documentation"><a class="anchor" href="#la-documentation"><img src="../assets/anchor.svg" alt></a>La documentation</h4><p>La documentation <strong>Swagger</strong> est écrite en YAML et suit les spécifications <strong>OpenApi</strong>. On ajoute simplement un <strong>operationId</strong> à chaque endpoint spécifié dans la <strong>SwaggerDoc</strong> (ils permettront de faire le lien avec les <strong>handlers</strong> à invoquer).</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-string">...</span>

<span class="hljs-attr">paths:</span> 
  <span class="hljs-string">/users/{userId}</span>
    <span class="hljs-attr">get:</span>
    <span class="hljs-attr">summary: Get user by id operationId: getUserById parameters:</span>
<span class="hljs-string">...</span>
</code></pre><h4 class="heading4" style="color: #B236A9" id="création-de-la-routerfactory"><a class="anchor" href="#création-de-la-routerfactory"><img src="../assets/anchor.svg" alt></a>Création de la RouterFactory</h4><pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">OpenAPI3RouterFactory.create(vertx, <span class="hljs-string">&quot;src/main/resources/swaggerdoc.yaml&quot;</span>, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    OpenAPI3RouterFactory routerFactory = ar.result();
  } 
});</code></pre><p><strong>OpenAPI3RouterFactory</strong> dispose d’une méthode create, prenant, entre autres, un path de fichier YAML, et un <strong>handler</strong> dans lequel seront associés opérations et <strong>handlers</strong> correspondant. </p>
<h4 class="heading4" style="color: #B236A9" id="association-opérations--handlers-et-génération-du-router"><a class="anchor" href="#association-opérations--handlers-et-génération-du-router"><img src="../assets/anchor.svg" alt></a>Association opérations / handlers et génération du router.</h4><pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-comment">//...</span>
routerFactory.addHandlerByOperationId(<span class="hljs-string">&quot;getUserById&quot;</span>, <span class="hljs-keyword">new</span> GetUserHandler()); routerFactory.addHandlerByOperationId(<span class="hljs-string">&quot;createUser&quot;</span>, <span class="hljs-keyword">new</span> PostUserHandler()); routerFactory.addHandlerByOperationId(<span class="hljs-string">&quot;deleteUser&quot;</span>, <span class="hljs-keyword">new</span> DeleteUserHan- dler());
<span class="hljs-comment">//...</span></code></pre><p>L’instance de <strong>OpenAPIRouterFactory</strong> nous permet de faire l’association entre les operationId spécifiés dans la documentation <strong>swagger</strong> et les <strong>handlers</strong>.
La génération du router pourra ensuite être effectuée avec :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">Router router = routerFactory.getRouter();</code></pre><h3 class="heading3" style="color: #B236A9" id="executer-du-code-bloquant---théorie"><a class="anchor" href="#executer-du-code-bloquant---théorie"><img src="../assets/anchor.svg" alt></a>Executer du code bloquant - Théorie</h3><p>On opte généralement pour Vertx lorsque le caractère non-bloquant d’un projet est un critère important. Il y a donc une règle à laquelle il ne faut pas déroger : <em>ne jamais bloquer l’Event Loop</em>. Cependant il arrive qu’il soit nécessaire de repasser sur un mode synchrone et exécuter des opérations bloquantes. Un cas type est l’écriture de fichiers de données (un export CVS par exemple).</p>
<p>Vertx permet de réaliser ce type d’opération avec des verticles particuliers, appelés <strong>Workers</strong>. Ceux-ci n’ont pas le même cycle de vie que les verticles classiques car non administrés
par une Event Loop : un <strong>Worker</strong> est exécuté avec un thread provenant du pool de <strong>Workers</strong>.</p>
<p>Afin de simplifier l’allocation des threads dédiés à l’exécution des <strong>workers</strong>, Vertx administre des Pools, nous offrant ainsi la possibilité de paramétrer le nombre de threads disponibles et donc de tâches bloquantes pouvant s’exécuter en même temps.</p>
<p><img src="./assets/workers-schema.png" alt="" title=""></p>
<h3 class="heading3" style="color: #B236A9" id="executer-du-code-bloquant---pratique"><a class="anchor" href="#executer-du-code-bloquant---pratique"><img src="../assets/anchor.svg" alt></a>Executer du code bloquant - Pratique</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-3"><a class="anchor" href="#dépendances-nécessaires-3"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><p><img src="./assets/workers-dependances.png" alt="" title=""></p>
<h4 class="heading4" style="color: #B236A9" id="méthode-1--lors-du-déploiement"><a class="anchor" href="#méthode-1--lors-du-déploiement"><img src="../assets/anchor.svg" alt></a>Méthode 1 : lors du déploiement.</h4><p>Comme précisé plus haut, un <strong>worker</strong> est un verticle comme les autres.
La différence fondamentale est qu’il sera exécuté depuis un thread issu du pool de thread de vertx dédié aux <strong>workers</strong> et non via l’event loop.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">DeploymentOptions opts=<span class="hljs-keyword">new</span> DeploymentOptions().setWorker(<span class="hljs-keyword">true</span>); 
Vertx.vertx().deployVerticle(<span class="hljs-keyword">new</span> ExampleVerticle(), opts);</code></pre><p>Lors du déploiement d’un verticle, il est possible de spécifier des <strong>DeploymentOptions</strong>, permettant entre autre de préciser s’il doit être déployé comme worker. Il est également possible de paramétrer le nombre maximal de threads d’un pool avec la méthode <strong>setWorkerPoolSize</strong>.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">DeploymentOptions opts=<span class="hljs-keyword">new</span> DeploymentOptions()
  .setWorker(<span class="hljs-keyword">true</span>)
  .setWorkerPoolSize(<span class="hljs-number">3</span>); 
Vertx.vertx().deployVerticle(<span class="hljs-keyword">new</span> ExampleVerticle(), opts);</code></pre><h4 class="heading4" style="color: #B236A9" id="méthode-2--avec-les-exécutors"><a class="anchor" href="#méthode-2--avec-les-exécutors"><img src="../assets/anchor.svg" alt></a>Méthode 2 : avec les exécutors.</h4><p>Une autre méthode pour exécuter du code bloquant consiste à utiliser la classe <strong>WorkerExecutor</strong>. Cette classe dispose d’une méthode <strong>executeBlocking</strong> permettant, comme son nom l’indique, d’exécuter des portions de code bloquant. Les blocs de code encapsulés par la méthode executeBlocking seront traités par un thread du pool de workers.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">WorkerExecutor workerExecutor = vertx.createSharedWorkerExecutor (<span class="hljs-string">&quot;worker-pool-example&quot;</span>, <span class="hljs-number">3</span>); 
workerExecutor.executeBlocking(future -&gt; {
<span class="hljs-comment">//...</span>
}, res -&gt; {
<span class="hljs-comment">// ... </span>
});</code></pre><p>Ici chaque tâche exécutée avec <strong>executeBlocking</strong> sera traitée par un thread du pool &quot;worker-pool-example&quot;, créé avec <strong>createSharedWorkerExecutor</strong>.</p>
<p><em>Les méthodes 1 et 2 sont assez similaires : vous bénéficiez d’un pool de trois workers vous permettant d’exécuter du code bloquant. Dans sa forme la plus simple, l’exécution de code bloquant peut également se faire via la méthode Vertx.executeBlocking qui s’utilise de la même façon que l’executeBlocking de WorkerExecutor.</em></p>
<h3 class="heading3" style="color: #B236A9" id="circuit-breaker"><a class="anchor" href="#circuit-breaker"><img src="../assets/anchor.svg" alt></a>Circuit Breaker</h3><p>Le pattern Circuit Breaker permet d’assurer la résilience de l’application, en offrant des scénarios alternatifs en cas de défaillances afin de garantir une continuité de service.</p>
<p><img src="./assets/circuit-breaker-schema.png" alt="" title=""></p>
<h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-4"><a class="anchor" href="#dépendances-nécessaires-4"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><p><img src="./assets/circuit-breaker-dependances.png" alt="" title=""></p>
<h4 class="heading4" style="color: #B236A9" id="initialisation"><a class="anchor" href="#initialisation"><img src="../assets/anchor.svg" alt></a>Initialisation</h4><pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">CircuitBreaker breaker = CircuitBreaker.create(<span class="hljs-string">&quot;breaker-example&quot;</span>, vertx,
  <span class="hljs-keyword">new</span> CircuitBreakerOptions() 
    .setMaxFailures(<span class="hljs-number">5</span>)<span class="hljs-comment">// (1) </span>
    .setMaxRetries(<span class="hljs-number">3</span>)<span class="hljs-comment">// (2) </span>
    .setTimeout(<span class="hljs-number">2000</span>)<span class="hljs-comment">// (3)</span></code></pre><p>Le circuit breaker est défini par le biais de <strong>CircuitBreakerOptions</strong>. Ici on définit le seuil d’échecs tolérés avant de passer le circuit en statut ouvert (1), le maximum de tentatives d’exécution d’une requête avant d’incrémenter le compteur d’échecs (2), et le temps de réponse maximum au-delà duquel on considère la requête en erreur (3).</p>
<h4 class="heading4" style="color: #B236A9" id="gestion-des-cas-derreurs"><a class="anchor" href="#gestion-des-cas-derreurs"><img src="../assets/anchor.svg" alt></a>Gestion des cas d&#39;erreurs</h4><pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">breaker.executeWithFallback(future -&gt; 
  WebClient.create(vertx)
    .get(<span class="hljs-number">8080</span>, <span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;/test&quot;</span>)
    .send(response -&gt; { <span class="hljs-comment">/*...*/</span> })
), fallback -&gt; { System.out.print(<span class="hljs-string">&quot;Target application can’t be called&quot;</span>);
}).setHandler(ar -&gt; System.out.print(<span class="hljs-string">&quot;Success&quot;</span>));</code></pre></div>

                        <div class="h2-part" id="div-vertx-pour-le-web">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#vertx-pour-le-web"><img src="../assets/anchor.svg" alt></a>Vertx pour le web</h2>

                            <div class="title-menu-container"><p class="title-menu" id="vertx-pour-le-web">Vertx pour le web</p></div>
<h3 class="heading3" style="color: #B236A9" id="servir-des-pages-web"><a class="anchor" href="#servir-des-pages-web"><img src="../assets/anchor.svg" alt></a>Servir des pages web</h3><p>Solution idéale pour construire rapidement des APIs légères et réactives, Vertx permet également de servir du contenu HTML.</p>
<h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-5"><a class="anchor" href="#dépendances-nécessaires-5"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><p><img src="./assets/web-page-dependances.png" alt="" title=""></p>
<h4 class="heading4" style="color: #B236A9" id="exposer-des-ressources-statiques"><a class="anchor" href="#exposer-des-ressources-statiques"><img src="../assets/anchor.svg" alt></a>Exposer des ressources statiques</h4><p>Servir des ressources statiques (comme les fichiers css ou les images) nécessite l’utilisation d’un <strong>StaticHandler</strong> qui, en fonction des demandes, transmettra les fichiers stockés dans un répertoire du filesystem. Par défaut ce répertoire est <strong>webroot</strong>, mais il est tout à fait possible de pointer sur un autre répertoire via la méthode <strong>setWebRoot</strong> du <strong>StaticHandler</strong>.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">router.route(<span class="hljs-string">&quot;/static/*&quot;</span>).handler(StaticHandler.create());</code></pre><h4 class="heading4" style="color: #B236A9" id="servir-une-page-html"><a class="anchor" href="#servir-une-page-html"><img src="../assets/anchor.svg" alt></a>Servir une page HTML</h4><p>Tout comme les réponses retournées par des APIs, servir du contenu HTML se fait
avec <strong>routingContext.response().end(...)</strong>. Le contenu renvoyé ici est passé en paramètre de la méthode end et sera dans ce cas du code HTML.</p>
<h4 class="heading4" style="color: #B236A9" id="le-templating"><a class="anchor" href="#le-templating"><img src="../assets/anchor.svg" alt></a>Le templating</h4><p>Plusieurs moteurs de templates peuvent être utilisés conjointement avec Vertx afin de rendre un contenu HTML (Thymeleaf, Freemarker, Jade, ...).</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">router.get(<span class="hljs-string">&quot;/page&quot;</span>).handler( 
  routingContext -&gt; {
    ThymeleafTemplateEngine engine = ThymeleafTemplateEngine. create();
    engine.render(routingContext, <span class="hljs-string">&quot;templates&quot;</span>, <span class="hljs-string">&quot;page.html&quot;</span>, res -&gt; { 
      <span class="hljs-keyword">if</span> (res.succeeded()) {
        routingContext.response().end(res.result());
      } 
    });
});</code></pre><p>Outre le <strong>RoutingContext</strong>, la méthode <strong>render</strong> de <strong>ThymeleafTemplateEngine</strong> prend en paramètre le nom du répertoire contenant les templates, le nom du template à utiliser et un handler à exécuter (en général cet handler renverra le code HTML généré).</p>
<h3 class="heading3" style="color: #B236A9" id="stocker-des-données--sessions"><a class="anchor" href="#stocker-des-données--sessions"><img src="../assets/anchor.svg" alt></a>Stocker des données : sessions</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-6"><a class="anchor" href="#dépendances-nécessaires-6"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/session-dependances.png" width="60%"/>

<h4 class="heading4" style="color: #B236A9" id="types-de-stockage"><a class="anchor" href="#types-de-stockage"><img src="../assets/anchor.svg" alt></a>Types de stockage</h4><p>Le stockage des données en session passe par la création d’une instance de <strong>SessionStore</strong>. Cette classe permet de spécifier le nom de la map qui contiendra les données de session.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">SessionStore sessionStore = LocalSessionStore.create(vertx, <span class="hljs-string">&quot;map&quot;</span>);</code></pre><p>Dans sa forme la plus simple, le stockage se fait localement au sein d’un même serveur HTTP. Cependant en production, plusieurs instances d’un même verticle peuvent exister au sein d’un même cluster. Les sessions sont donc amenées à être partagées entre plusieurs serveurs HTTP. Dans ce cas de figure, il sera nécessaire d’utiliser <strong>ClusturedSessionStore</strong> et non <strong>LocalSessionStore</strong>. Les sessions seront alors stockées dans une map distribuée.</p>
<p><em>Bien que tout à fait faisable avec Vertx, le stockage des données en session est cependant
à éviter : pour suivre les principes de scalabilité et de résilience il est conseillé de favoriser le stateless.</em></p>
<p><img src="./assets/session-store-schema.png" alt="" title=""></p>
<h4 class="heading4" style="color: #B236A9" id="accès-aux-données"><a class="anchor" href="#accès-aux-données"><img src="../assets/anchor.svg" alt></a>Accès aux données</h4><p>L’accès aux données de session suit le même schéma que l’accès au body des requêtes POST. On déclare le <strong>SessionHandler</strong>, qui sera associé au <strong>router</strong>.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">SessionHandler sessionHandler = SessionHandler.create(sessionStore); router.route().handler(sessionHandler);</code></pre><p>L’accès aux données pourra alors être opéré par le biais d’un objet <strong>Session</strong>, obtenu via un appel au <strong>RoutingContext</strong>. <strong>Session</strong> se manipule comme une HashMap classique.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">Session session = routingContext.session(); 
session.put(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);</code></pre><h3 class="heading3" style="color: #B236A9" id="stocker-des-données--cookies"><a class="anchor" href="#stocker-des-données--cookies"><img src="../assets/anchor.svg" alt></a>Stocker des données : cookies</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-7"><a class="anchor" href="#dépendances-nécessaires-7"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/coockies-dependances.png" width="60%"/>

<h4 class="heading4" style="color: #B236A9" id="mise-en-oeuvre"><a class="anchor" href="#mise-en-oeuvre"><img src="../assets/anchor.svg" alt></a>Mise en oeuvre</h4><p>De la même façon que pour les sessions, l’accès aux données stockées sous forme de cookies se fait par le biais d’un handler spécifique : <strong>CookieHandler</strong>.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">router.route().handler(CookieHandler.create());</code></pre><p>Le <strong>RoutingContext</strong> permettra de stocker de nouveaux cookies et de manipuler leurs données.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">routingContext.addCookie(Cookie.cookie(<span class="hljs-string">&quot;cookie-example&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>)); 
<span class="hljs-comment">//...</span>
Cookie cookieExample = routingContext.getCookie(<span class="hljs-string">&quot;cookie-example&quot;</span>); 
String value = cookieExample.getValue();</code></pre><h3 class="heading3" style="color: #B236A9" id="saisir-des-données--les-formulaires"><a class="anchor" href="#saisir-des-données--les-formulaires"><img src="../assets/anchor.svg" alt></a>Saisir des données : les formulaires.</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-8"><a class="anchor" href="#dépendances-nécessaires-8"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/coockies-dependances.png" width="60%"/>

<h4 class="heading4" style="color: #B236A9" id="créer-le-formulaire"><a class="anchor" href="#créer-le-formulaire"><img src="../assets/anchor.svg" alt></a>Créer le formulaire</h4><p>La création d’un formulaire exploitable par Vertx n’a pas de prérequis particuliers, seul l’attribut <strong>name</strong> des inputs est essentiel : c’est avec son nom qu’on pourra rechercher un input et accéder à sa valeur.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;radio1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;A&quot;</span>/&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;radio2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;B&quot;</span>/&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input3&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;radio3&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;C&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><h4 class="heading4" style="color: #B236A9" id="récupérer-les-données-saisies"><a class="anchor" href="#récupérer-les-données-saisies"><img src="../assets/anchor.svg" alt></a>Récupérer les données saisies</h4><p>Comme précisé dans la partie précédente le nom de l’input est important, car il permet de récupérer la valeur saisie avec la méthode <strong>getFormAttribute</strong> de <strong>HttpServerRequest</strong> (qui prend en paramètre le nom de l’input).</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">routingContext.request().getFormAttribute(<span class="hljs-string">&quot;radio1&quot;</span>)</code></pre><p>Une autre méthode (<strong>formAttributes</strong>), également fournie par <strong>HttpServerRequest</strong>, offre la possibilité de récupérer l’ensemble des inputs sous la forme d’une <strong>MultiMap</strong>.</p>
</div>

                        <div class="h2-part" id="div-levent-bus-le-système-nerveux-de-vertx">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#levent-bus-le-système-nerveux-de-vertx"><img src="../assets/anchor.svg" alt></a>L&#39;Event Bus, le système nerveux de Vertx</h2>

                            <div class="title-menu-container"><p class="title-menu" id="levent-bus-le-système-nerveux-de-vertx">L&#39;Event Bus, le système nerveux de Vertx</p></div>
<h3 class="heading3" style="color: #B236A9" id="event-bus---théorie"><a class="anchor" href="#event-bus---théorie"><img src="../assets/anchor.svg" alt></a>Event Bus - Théorie</h3><p>Véritable système nerveux de Vertx, l’event bus permet à différentes entités d’une application de communiquer entre elles via échange de messages (entités qui peuvent se trouver, ou non, dans la même instance Vertx). Un des principaux intérêts est que les parties communicantes peuvent être écrites dans des langages différents, mais qu’il est également tout à fait envisageable de lier du code Javascript, exécuté dans un navigateur, à l’Event Bus (via <strong>SockJs</strong> par exemple).</p>
<p>L’envoi de messages sur le bus se fait sur une adresse, qui n’est ni plus ni moins qu’une simple chaine de caractères. Chaque <strong>consumer</strong> (qui est généralement un verticle) reçoit et traite les messages en s’abonnant à cette adresse (modèle <strong>publish / subscribe</strong>).</p>
<p>Il supporte aussi le modèle point à point et <strong>request/response</strong>.
On retrouve donc l’aspect &quot;message oriented&quot; du manifeste reactive. Ce bus va nous permettre de découpler les composants, et de profiter d’une scalabilité horizontale (un verticle du cluster va traiter un message).</p>
<p><img src="./assets/eventbus-theorie-schema.png" alt="" title=""></p>
<h3 class="heading3" style="color: #B236A9" id="event-bus---en-local"><a class="anchor" href="#event-bus---en-local"><img src="../assets/anchor.svg" alt></a>Event Bus - En local</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-9"><a class="anchor" href="#dépendances-nécessaires-9"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/eventbus-local-dependances.png" width="60%"/>

<h4 class="heading4" style="color: #B236A9" id="réception-des-messages-abonnements"><a class="anchor" href="#réception-des-messages-abonnements"><img src="../assets/anchor.svg" alt></a>Réception des messages (Abonnements)</h4><pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// ...</span>
  vertx.eventBus().consumer( <span class="hljs-string">&quot;address-A&quot;</span>, message -&gt; System.out.println(message.body()));</code></pre><p>Dans cet exemple on affiche le contenu du message réceptionné à l’adresse &quot;address-A&quot;.</p>
<h4 class="heading4" style="color: #B236A9" id="envoi-des-messages"><a class="anchor" href="#envoi-des-messages"><img src="../assets/anchor.svg" alt></a>Envoi des messages</h4><p>La publication d’un message peut se faire de deux façons :</p>
<ul>
<li>Via la méthode <strong>publish</strong> -&gt; l’ensemble des consommateurs abonnés à l’adresse traitera le message (<strong>modèle publish / subscribe</strong>).</li>
<li>Via la méthode <strong>send</strong> -&gt; un seul consommateur traitera le message même si d’autres sont abonnés à la même adresse (<strong>modèle point to point</strong>).</li>
</ul>
<p>Ces deux méthodes prennent en paramètre l’adresse de publication et le contenu
du message.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">vertx.eventBus().publish(<span class="hljs-string">&quot;address-A&quot;</span>, <span class="hljs-string">&quot;Message content&quot;</span>); 
vertx.eventBus().send(<span class="hljs-string">&quot;address-A&quot;</span>, <span class="hljs-string">&quot;Message content&quot;</span>);</code></pre><h3 class="heading3" style="color: #B236A9" id="event-bus--en-cluster"><a class="anchor" href="#event-bus--en-cluster"><img src="../assets/anchor.svg" alt></a>Event Bus – En cluster</h3><p>Dans sa forme la plus simple, la communication inter-verticle se fait au sein de la même instance Vertx sans aucune complexité. Cependant dans le cas d’applications distribuées, plusieurs instances Vertx peuvent coexister sur le réseau et être exécutées sur des JVM différentes.</p>
<p>Or chaque instance gère son propre Event Bus. Il est donc nécessaire de s’appuyer sur un Cluster Manager qui permettra de grouper les instances et de constituer un seul Event Bus partagé.</p>
<p><img src="./assets/eventbus-cluster-schema.png" alt="" title=""></p>
<h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-10"><a class="anchor" href="#dépendances-nécessaires-10"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/eventbus-cluster-dependances.png" width="80%"/>

<h4 class="heading4" style="color: #B236A9" id="mise-en-oeuvre-1"><a class="anchor" href="#mise-en-oeuvre-1"><img src="../assets/anchor.svg" alt></a>Mise en oeuvre</h4><pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-comment">//...</span>
ClusterManager mng = <span class="hljs-keyword">new</span> HazelcastClusterManager();
VertxOptions options = <span class="hljs-keyword">new</span> VertxOptions().setClusterManager(mng); Vertx.clusteredVertx(options, res -&gt; {
  <span class="hljs-keyword">if</span> (res.succeeded()) {
    Vertx vertx = res.result(); vertx.eventBus().publish(<span class="hljs-string">&quot;address-B&quot;</span>, <span class="hljs-string">&quot;Message content&quot;</span>);
  }
});</code></pre><p>On instancie un <strong>HazelcastClusterManager</strong> qui sera ensuite utilisé pour initialiser le cluster. Si c’est un succès, la suite des opérations sera la même que pour une exécution locale. Vertx supporte d’autres Cluster Manager comme Zookeeper (<strong>ZookeeperClusterManager</strong> du module <strong>vertx-zookeeper</strong>), Infinispan (<strong>InfinispanClusterManager</strong> du module <strong>vertx-infinispan</strong>), Ignite (<strong>IgniteClusterManager</strong> du module <strong>vertx-ignite</strong>). Qu’il soit local ou distribué l’event bus permet donc aux composants d’une application d’échanger facilement des données de manière asynchrone et non-bloquante, et ne nécessite pas l’intervention d’un broker de messages.</p>
</div>

                        <div class="h2-part" id="div-gérer-efficacement-les-micro-services">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#gérer-efficacement-les-micro-services"><img src="../assets/anchor.svg" alt></a>Gérer efficacement les micro services</h2>

                            <div class="title-menu-container"><p class="title-menu" id="gérer-efficacement-les-micro-services">Gérer efficacement les micro services</p></div>
<h3 class="heading3" style="color: #B236A9" id="services-discovery---théorie"><a class="anchor" href="#services-discovery---théorie"><img src="../assets/anchor.svg" alt></a>Services Discovery - Théorie</h3><p>Chaque entité d’un système peut être vue comme un service. Qu’il s’agisse de endpoints HTTP, de sources de données ou d’un proxy, chaque service peut être décrit et référencé dans l’annuaire dans le but d’être appelable par les autres services sans que ceux-ci n’aient connaissance de l’adresse de ce service. Tout comme pour l’Event Bus, ce mécanisme, appelé découverte de services, garantit donc une certaine <strong>transparence de localisation</strong>.</p>
<p><img src="./assets/services-discovery-schema.png" alt="" title=""></p>
<p>Ce schéma illustre ce concept : les endpoints d’<strong>Account Service</strong> (exposés par <strong>Account Verticle</strong>) sont référencés dans le Service Registry. Ce dernier est observé et utilisé par le Customer Service pour récupérer l’adresse d’Account Service et donc déterminer comment appeler les endpoints exposés par <strong>Account Verticle</strong>.
Vertx propose ses propres classes permettant de monter un annuaire de service, mais offre également des connecteurs pour interagir avec d’autres solutions (Consul par exemple, via le client mis à disposition par <strong>vertx-consul-client</strong>).</p>
<h3 class="heading3" style="color: #B236A9" id="services-discovery---mise-en-pratique"><a class="anchor" href="#services-discovery---mise-en-pratique"><img src="../assets/anchor.svg" alt></a>Services Discovery - Mise en pratique</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-11"><a class="anchor" href="#dépendances-nécessaires-11"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/services-discovery-dependances.png" width="60%"/>

<h4 class="heading4" style="color: #B236A9" id="créer-lannuaire-de-services"><a class="anchor" href="#créer-lannuaire-de-services"><img src="../assets/anchor.svg" alt></a>Créer l&#39;annuaire de services</h4><p>La création d’un annuaire de services avec Vertx implique l’instanciation d’un objet <strong>ServiceDiscovery</strong> :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">ServiceDiscovery discovery = ServiceDiscovery.create(vertx);</code></pre><h4 class="heading4" style="color: #B236A9" id="référencer-un-service-dans-lannuaire"><a class="anchor" href="#référencer-un-service-dans-lannuaire"><img src="../assets/anchor.svg" alt></a>Référencer un service dans l&#39;annuaire</h4><p>La publication d’un service (ci-dessous un endpoint HTTP) revient à ajouter un <strong>Record</strong> dans l’annuaire. Chaque service référencé est caractérisé par un nom, une localisation, et optionnellement des métadonnées.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">Record record = HttpEndpoint.createRecord(<span class="hljs-string">&quot;service-name&quot;</span>, <span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-number">8080</span>, <span class="hljs-string">&quot;/test&quot;</span>);
discovery.publish(record, ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) { 
    System.out.println(<span class="hljs-string">&quot;Service published&quot;</span>); 
  }
});</code></pre><h4 class="heading4" style="color: #B236A9" id="rechercher-un-service-dans-lannuaire"><a class="anchor" href="#rechercher-un-service-dans-lannuaire"><img src="../assets/anchor.svg" alt></a>Rechercher un service dans l&#39;annuaire</h4><p>Il est possible de rechercher des services en utilisant des filtres (applicables sur différentes caractéristiques d’un service) :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">discovery.getRecord(r -&gt; r.getName().equals(<span class="hljs-string">&quot;service-name&quot;</span>), ar -&gt; {
  <span class="hljs-keyword">if</span> (ar.succeeded()) { 
    System.out.println(<span class="hljs-string">&quot;Service found&quot;</span>); 
  }
});</code></pre><p>L’appel au service pourra ensuite se faire comme suit (la méthode <strong>getAs</strong> prenant en paramètre le type de service à récupérer) :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-keyword">if</span> (ar.succeeded()) {
  Record record = ar.result();
  ServiceReference serviceReference = discovery.getReference(record);
  HttpClient client = serviceReference.getAs(HttpClient.class); 
  client.get(<span class="hljs-string">&quot;HTTP://address:port/resource&quot;</span>).end();
  <span class="hljs-comment">// ...</span>
  serviceReference.release();}</code></pre></div>

                        <div class="h2-part" id="div-tester-lapplication">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#tester-lapplication"><img src="../assets/anchor.svg" alt></a>Tester L&#39;application</h2>

                            <div class="title-menu-container"><p class="title-menu" id="tester-lapplication">Tester L&#39;application</p></div>
<h3 class="heading3" style="color: #B236A9" id="les-collections-de-tests-avec-vertx-unit"><a class="anchor" href="#les-collections-de-tests-avec-vertx-unit"><img src="../assets/anchor.svg" alt></a>Les collections de tests avec Vertx Unit</h3><p>Vertx Unit est un module apporté par Vertx, se basant sur des frameworks de tests existants et permettant d’écrire des tests unitaires asynchrones.</p>
<h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-12"><a class="anchor" href="#dépendances-nécessaires-12"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/tests-dependances.png" width="50%">

<h4 class="heading4" style="color: #B236A9" id="ecrire-une-suite-de-tests"><a class="anchor" href="#ecrire-une-suite-de-tests"><img src="../assets/anchor.svg" alt></a>Ecrire une suite de tests</h4><p>En règle générale, tester son application revient à écrire un ensemble de cas de tests. La classe <strong>TestSuite</strong> simplifie cette démarche en apportant quelques méthodes utiles pour grouper ces cas de tests et séquencer leurs exécutions.</p>
<h5 class="heading5" style="color: #B236A9" id="instancier-une-testsuite"><a class="anchor" href="#instancier-une-testsuite"><img src="../assets/anchor.svg" alt></a>Instancier une TestSuite</h5><p>La création d’un objet <strong>TestSuite</strong> passe par un appel à la méthode <strong>create</strong>, prenant en paramètre une chaine de caractères (le nom que l’on souhaite donner à la <strong>TestSuite</strong>).</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">TestSuite testSuite = TestSuite.create(<span class="hljs-string">&quot;test-suite-example&quot;</span>);</code></pre><h5 class="heading5" style="color: #B236A9" id="déclarer-des-tests"><a class="anchor" href="#déclarer-des-tests"><img src="../assets/anchor.svg" alt></a>Déclarer des tests</h5><p>L’instance de <strong>TestSuite</strong> est utilisée pour déclarer des cas de <strong>test</strong>. La méthode test prend en paramètre le nom du test, ainsi qu’un callback à exécuter.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">testSuite.test(<span class="hljs-string">&quot;test1&quot;</span>, context -&gt; { 
   <span class="hljs-comment">//...</span>
});</code></pre><h5 class="heading5" style="color: #B236A9" id="exécuter-une-test-suite"><a class="anchor" href="#exécuter-une-test-suite"><img src="../assets/anchor.svg" alt></a>Exécuter une test suite</h5><p>La classe <strong>TestSuite</strong> dispose d’une méthode run, qui permet de lancer l’exécution.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">testSuite.run() ;</code></pre><p>Il est également possible de passer des paramètres à cette méthode, et notamment une instance de <strong>TestOptions</strong>. Cette classe est entre autres utilisée pour déclarer des &quot;reporters&quot; permettant d’exporter les résultats des tests vers des sorties diverses.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">ReportOptions fileReport = <span class="hljs-keyword">new</span> ReportOptions().setTo(<span class="hljs-string">&quot;file:.&quot;</span>).setFormat(<span class="hljs-string">&quot;simple&quot;</span>); 
testSuite.run(<span class="hljs-keyword">new</span> TestOptions().addReporter(fileReport));</code></pre><p>Dans l’exemple précédent, une instance de <strong>ReportOptions</strong> permet de spécifier que la sortie d’exécution des tests sera un ensemble de fichiers (l’argument de <strong>setTo</strong> aura alors la forme <strong>file:$DIRECTORY</strong> où $DIRECTORY sera remplacé par le chemin où seront sauvegardés les fichiers). Il est possible de spécifier d’autres sorties en changeant l’argument de la méthode <strong>setTo</strong> par :</p>
<ul>
<li>console &gt; les résultats des tests seront affichés dans la console</li>
<li>bus :$ADDRESS &gt; exports sous forme de messages, envoyé sur un Event Bus (on remplacera $ADDRESS par l’adresse à laquelle on envoie les messages)</li>
<li>Log :$LOGGER &gt; exports sous forme de logs (on remplacera $LOGGER par le nom du logger à utiliser)</li>
</ul>
<h3 class="heading3" style="color: #B236A9" id="chaîner-ses-tests-vertx-unit"><a class="anchor" href="#chaîner-ses-tests-vertx-unit"><img src="../assets/anchor.svg" alt></a>Chaîner ses tests Vertx Unit</h3><p>Comme nous l’avons vu dans la partie précédente, l’écriture de cas de tests avec Vertx Unit est assez triviale. Mais ce module ne se limite pas à l’écriture de cas de tests autonomes : il est possible de construire de véritables scénarios en chaînant les cas de tests.</p>
<h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-13"><a class="anchor" href="#dépendances-nécessaires-13"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/tests-dependances.png" width="50%">

<h4 class="heading4" style="color: #B236A9" id="mise-en-oeuvre-2"><a class="anchor" href="#mise-en-oeuvre-2"><img src="../assets/anchor.svg" alt></a>Mise en oeuvre</h4><p>L’enchainement logique des tests implique que ceux-ci puissent partager des objets. Pour cela les callbacks ont à disposition un <strong>context</strong>, s’utilisant comme une Hashmap. On peut donc stocker une donnée lors de l’exécution d’un cas de test, et l’utiliser durant l’exécution du suivant.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">testSuite.before(context -&gt; { 
  context.put(<span class="hljs-string">&quot;result&quot;</span>, <span class="hljs-number">10</span>);
}).test(<span class="hljs-string">&quot;increase-result&quot;</span>, context -&gt; {
  <span class="hljs-keyword">int</span> newResult = ((<span class="hljs-keyword">int</span>)context.get(<span class="hljs-string">&quot;result&quot;</span>)) + <span class="hljs-number">8</span>; 
  context.assertEquals(newResult, <span class="hljs-number">18</span>); 
  context.put(<span class="hljs-string">&quot;result&quot;</span>, newResult);
}).test(<span class="hljs-string">&quot;divide-result&quot;</span>, context -&gt; {
  <span class="hljs-keyword">int</span> newResult = ((<span class="hljs-keyword">int</span>)context.get(<span class="hljs-string">&quot;result&quot;</span>)) / <span class="hljs-number">2</span>; 
  context.assertTrue(newResult &lt; <span class="hljs-number">10</span>); 
  context.put(<span class="hljs-string">&quot;result&quot;</span>, newResult);
}).after(context -&gt; { 
  <span class="hljs-comment">//...</span>
});</code></pre><p>Dans l’exemple précédent, on stocke dans le <strong>context</strong> un entier &quot;result&quot; depuis le callback de la méthode <strong>before</strong> (méthode utilisée pour initialiser une <strong>TestSuite</strong> avant son exécution). La valeur de &quot;result&quot; est ensuite mise à jour, testée et restockée par le premier cas de test &quot;increase-result&quot;. Le second cas de test &quot;divide-result&quot; sera lancé une fois que &quot;increase-result&quot; aura terminé son exécution et pourra à son tour exploiter la valeur de &quot;result&quot;. C’est également l’objet <strong>context</strong> qui fournit les méthodes d’assertions.</p>
</div>

                        <div class="h2-part" id="div-déployer-et-administrer">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#déployer-et-administrer"><img src="../assets/anchor.svg" alt></a>Déployer et administrer</h2>

                            <div class="title-menu-container"><p class="title-menu" id="déployer-et-administrer">Déployer et administrer</p></div>
<h3 class="heading3" style="color: #B236A9" id="le-cli-vertx"><a class="anchor" href="#le-cli-vertx"><img src="../assets/anchor.svg" alt></a>Le CLI Vertx</h3><p>Vertx dispose d’une interface en ligne de commande très pratique permettant de lancer des verticles en précisant des options de déploiement.</p>
<h4 class="heading4" style="color: #B236A9" id="installation"><a class="anchor" href="#installation"><img src="../assets/anchor.svg" alt></a>Installation</h4><p>1 - Installer une JDK 8 sur le poste de développement (impératif si on souhaite compiler des verticles écrits en Java).</p>
<p>2 - Télécharger la dernière version de Vertx depuis HTTPS://vertx.io/download/.</p>
<p>3 - Dézipper l’archive.</p>
<p>4 - Ajouter le bin contenu dans le répertoire obtenu au PATH de la machine.</p>
<h4 class="heading4" style="color: #B236A9" id="quelques-commandes-utiles"><a class="anchor" href="#quelques-commandes-utiles"><img src="../assets/anchor.svg" alt></a>Quelques commandes utiles</h4><ul>
<li><p>Compiler et déployer un verticle </p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">$</span><span class="bash"> vertx run HelloVerticle.java</span></code></pre></li>
<li><p>Déployer 3 instances d&#39;un verticle</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">$</span><span class="bash"> vertx run HelloVerticle.java -instances 3</span></code></pre></li>
<li><p>Déployer un worker</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">$</span><span class="bash"> vertx run HelloVerticle.java -worker</span></code></pre></li>
<li><p>Spécifier des configurations lors du déploiement</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">$</span><span class="bash"> vertx run HelloVerticle.java -config /path/to/config.json</span></code></pre></li>
<li><p>Déployer un verticle dans un environnement clusterisé </p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">$</span><span class="bash"> vertx run HelloVerticle.java -cluster</span></code></pre><p>Vertx créera automatiquement un Event Bus pour permettre la communication inter-verticles.</p>
</li>
<li><p>Redéployer automatiquement à chaque modification</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">$</span><span class="bash"> vertx run HelloVerticle --redeploy=<span class="hljs-string">&quot;**&amp;#47;*.class&quot;</span> --launcher-class=io.vertx.core.Launcher</span></code></pre><p>L’option -redeploy prend ici en paramètre une regex Ant-style permettant d’indiquer l’ensemble de fichiers à observer.</p>
</li>
<li><p>Lancer un verticle en tâche de fond</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">$</span><span class="bash"> vertx run HelloVerticle start — -vertx-id=hello-verticle</span></code></pre><p>On utilisera list et stop pour lister et stopper les verticles.</p>
</li>
</ul>
<h3 class="heading3" style="color: #B236A9" id="configurations-et-logs"><a class="anchor" href="#configurations-et-logs"><img src="../assets/anchor.svg" alt></a>Configurations et logs</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-14"><a class="anchor" href="#dépendances-nécessaires-14"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/logs-dependances.png" width="50%">

<h4 class="heading4" style="color: #B236A9" id="configurations"><a class="anchor" href="#configurations"><img src="../assets/anchor.svg" alt></a>Configurations</h4><p>Vertx supporte différents types de sources de données depuis lesquelles il est possible d’extraire les configurations utilisables par nos applications, et notamment les <strong>fichiers</strong> (JSON,YAML,...), les <strong>variables d’environnement</strong>,les <strong>endpoints HTTP</strong> ou encore les <strong>dépôts Git</strong>. Pour d’accéder aux configurations stockées à la fois dans un fichier et dans des variables d’environnement, un objet <strong>ConfigRetrieverOptions</strong> doit être défini :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">ConfigStoreOptions fileStore = <span class="hljs-keyword">new</span> ConfigStoreOptions()
  .setType(<span class="hljs-string">&quot;file&quot;</span>)
  .setConfig(<span class="hljs-keyword">new</span> JsonObject().put(<span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-string">&quot;config-file.json&quot;</span>));
ConfigStoreOptions envStore = <span class="hljs-keyword">new</span> ConfigStoreOptions().setType(<span class="hljs-string">&quot;env&quot;</span>); ConfigRetrieverOptions options = <span class="hljs-keyword">new</span> ConfigRetrieverOptions()
  .addStore(fileStore) 
  .addStore(envStore);</code></pre><p>Il sera ensuite utilisé pour récupérer un <strong>JsonObject</strong> contenant l’ensemble des configurations (à l’instar d’une <strong>HashMap</strong>, chaque valeur du <strong>JsonObject</strong> est accessible via une clé) :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">ConfigRetriever.create(vertx, options).getConfig(ar -&gt; { 
  <span class="hljs-keyword">if</span> (ar.succeeded()) {
    JsonObject config = ar.result(); 
  }
});</code></pre><h4 class="heading4" style="color: #B236A9" id="logs"><a class="anchor" href="#logs"><img src="../assets/anchor.svg" alt></a>Logs</h4><p>L’implémentation par défaut de l’API de logging fournie par Vertx s’appuie sur <strong>java.util.logging</strong> (d’autres frameworks de logging tel-que Log4j sont également supportés). Au démarrage de l’application, Vertx ira scruter le fichier <strong>vertx-default-jul-logging.properties</strong> situé sous <strong>/src/main/resources</strong>. Le logging se fera alors de façon très classique.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">Logger logger = LoggerFactory.getLogger(<span class="hljs-string">&quot;ExampleVerticle&quot;</span>) 
<span class="hljs-comment">//...</span>
logger.error(<span class="hljs-string">&quot;Error during Verticle initialization&quot;</span>);</code></pre><h3 class="heading3" style="color: #B236A9" id="déploiement-rapide-de-lapplication"><a class="anchor" href="#déploiement-rapide-de-lapplication"><img src="../assets/anchor.svg" alt></a>Déploiement rapide de l&#39;application</h3><p>Lors du build d’une application Vertx, un fat-jar est généré et peut être lancé via la commande <strong>java -jar</strong>. Cependant durant les phases de développement, cette méthode peut être assez contraignante. N’ayez crainte, il existe d’autres techniques pour construire, déployer et lancer des verticles.</p>
<h4 class="heading4" style="color: #B236A9" id="en-utilisant-le-plugin-maven"><a class="anchor" href="#en-utilisant-le-plugin-maven"><img src="../assets/anchor.svg" alt></a>En utilisant le plugin maven</h4><p>La méthode la plus simple pour lancer localement une application Vertx est d’utiliser le plugin <strong>vertx-maven-plugin</strong>. Une fois ajouté au pom.xml, lancez la commande suivante pour démarrer l’application :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">$</span><span class="bash"> mvn vertx:start</span></code></pre><p>Et pour la stopper :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-meta">$</span><span class="bash"> mvn vertx:stop</span></code></pre><h4 class="heading4" style="color: #B236A9" id="en-utilisant-la-classe-launcher-de-vertx"><a class="anchor" href="#en-utilisant-la-classe-launcher-de-vertx"><img src="../assets/anchor.svg" alt></a>En utilisant la classe Launcher de Vertx</h4><p>Vertx fournit la classe Launcher, utilisable avec <strong>maven-shade-plugin</strong>. Après avoir ajouté le plugin au pom.xml, il est nécessaire de spécifier dans sa configuration quelle sera la classe utilisée comme Launcher et quel est le verticle à lancer.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80"><span class="hljs-tag">&lt;<span class="hljs-name">manifestEntries</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">Main-Class</span>&gt;</span>io.vertx.core.Launcher<span class="hljs-tag">&lt;/<span class="hljs-name">Main-Class</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">Main-Verticle</span>&gt;</span>ExampleVerticle<span class="hljs-tag">&lt;/<span class="hljs-name">Main-Verticle</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">manifestEntries</span>&gt;</span></code></pre><h4 class="heading4" style="color: #B236A9" id="programmatiquement"><a class="anchor" href="#programmatiquement"><img src="../assets/anchor.svg" alt></a>Programmatiquement</h4><p>Les verticles sont déployables depuis le code de l’application :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">Vertx.vertx().deployVerticle(<span class="hljs-keyword">new</span> ExampleVerticle());</code></pre><h3 class="heading3" style="color: #B236A9" id="déploiement-avancé-et-scalabilité"><a class="anchor" href="#déploiement-avancé-et-scalabilité"><img src="../assets/anchor.svg" alt></a>Déploiement avancé et scalabilité</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-15"><a class="anchor" href="#dépendances-nécessaires-15"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/deploy-dependances.png" width="90%">

<h4 class="heading4" style="color: #B236A9" id="préciser-des-options-de-déploiement"><a class="anchor" href="#préciser-des-options-de-déploiement"><img src="../assets/anchor.svg" alt></a>Préciser des options de déploiement</h4><p>Les <strong>DeploymentOptions</strong> permettent de spécifier divers critères utilisés par Vertx lors du démarrage des verticles, notamment le nombre d’instances d’un même verticle.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">DeploymentOptions opts=<span class="hljs-keyword">new</span> DeploymentOptions().setInstances(<span class="hljs-number">3</span>); 
Vertx.vertx().deployVerticle(<span class="hljs-keyword">new</span> ExampleVerticle(), opts);</code></pre><p>Ici les trois instances d’<strong>ExampleVerticle</strong> écouteront le port 8080. La redirection des requêtes sur telle ou telle instance est automatiquement réalisée par Vertx (stratégie <strong>Round Robin</strong>).</p>
<h4 class="heading4" style="color: #B236A9" id="externaliser-les-options-de-déploiements"><a class="anchor" href="#externaliser-les-options-de-déploiements"><img src="../assets/anchor.svg" alt></a>Externaliser les options de déploiements</h4><p>Les options et le déploiement à proprement parler peuvent être découplés.
En effet, les informations comme le nombre d’instances d’un verticle ne sont que des paramètres pouvant être centralisés dans un fichier de configuration Json.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">{
  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;com.ineat.ExampleVerticle&quot;</span>,
  <span class="hljs-attr">&quot;instances&quot;</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">&quot;worker&quot;</span>: <span class="hljs-literal">true</span>
}</code></pre><p>Le toolkit d’Eclipse simplifie une nouvelle fois la vie du développeur en mettant à disposition la classe <strong>ServiceFactory</strong> qui, une fois ajoutée à l’instance Vertx, se chargera de collecter les options de déploiement spécifiées dans le fichier de configuration.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">vertx.registerVerticleFactory(<span class="hljs-keyword">new</span> ServiceVerticleFactory());</code></pre><p>En supposant que le fichier contenant les options de déploiement d’<strong>ExampleVerticle</strong> se nomme <strong>config-example-service.json</strong>, le déploiement se fera alors comme suit :</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">vertx.deployVerticle(<span class="hljs-string">&quot;service:config-example-service&quot;</span>);</code></pre></div>

                        <div class="h2-part" id="div-observabilité">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#observabilité"><img src="../assets/anchor.svg" alt></a>Observabilité</h2>

                            <div class="title-menu-container"><p class="title-menu" id="observabilité">Observabilité</p></div>
<h3 class="heading3" style="color: #B236A9" id="contrôler-létat-dune-application"><a class="anchor" href="#contrôler-létat-dune-application"><img src="../assets/anchor.svg" alt></a>Contrôler l&#39;état d&#39;une application</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-16"><a class="anchor" href="#dépendances-nécessaires-16"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/monitor-dependances.png" width="55%">

<h4 class="heading4" style="color: #B236A9" id="healthcheck"><a class="anchor" href="#healthcheck"><img src="../assets/anchor.svg" alt></a>HealthCheck</h4><p>Le principal intérêt d’un healthcheck est de pouvoir surveiller le statut de l’application. Il permet aussi de contrôler l’état des briques liées à cette application (autres services, bases de données, ...) ce qui permettra d’établir un diagnostic précis en cas de panne et d’identifier quel composant pose problème.</p>
<img src="./assets/healthcheck-schema.png">

<p>Contrôler l’état de santé d’une application est facile grâce au <strong>HealthCheckHandler</strong> (fourni par le module <strong>vertx-health-check</strong>). Cet handler est personnalisable puisqu’il est tout à fait possible d’ajouter des contrôles sous la forme de procédure en utilisant la méthode <strong>register</strong> (prenant en paramètre une chaine qui permettra d’identifier cette procédure,
et la procédure elle-même).</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">HealthCheckHandler healthCheckHandler = HealthCheckHandler. create(vertx);
healthCheckHandler.register(<span class="hljs-string">&quot;control-db&quot;</span>, future -&gt; {
  dbClient.getConnection(connection -&gt; { 
    <span class="hljs-keyword">if</span> (connection.failed())
      future.complete(Status.KO()); 
    <span class="hljs-keyword">else</span>
      future.complete(Status.OK());
});
healthCheckHandler.register(<span class="hljs-string">&quot;control-payment-service&quot;</span>, future -&gt; {...}); router.get(<span class="hljs-string">&quot;/health&quot;</span>).handler(healthCheckHandler);</code></pre><h3 class="heading3" style="color: #B236A9" id="exposer-des-indicateurs---théorie"><a class="anchor" href="#exposer-des-indicateurs---théorie"><img src="../assets/anchor.svg" alt></a>Exposer des indicateurs - Théorie</h3><p>Les healthchecks sont des solutions fiables pour contrôler si une application est disponible. Cependant, il est possible d’aller plus loin en exposant des données utiles grâce aux métriques : la consommation CPU, la mémoire utilisée, le nombre de verticles déployés, ... <strong>Micrometer</strong> est une solution parmi d’autres et pour laquelle Vertx fournit un module. Ainsi <strong>vertx-micrometer-metrics</strong> contient tout le nécessaire pour remonter des métriques qui pourront être exploitées par des solutions comme <strong>Prometheus</strong> ou <strong>InfluxDb</strong>, et présentées dans des dashboard <strong>Grafana</strong>.</p>
<img src="./assets/metrics-schema.png">

<h3 class="heading3" style="color: #B236A9" id="exposer-des-indicateurs---mise-en-pratique"><a class="anchor" href="#exposer-des-indicateurs---mise-en-pratique"><img src="../assets/anchor.svg" alt></a>Exposer des indicateurs - Mise en pratique</h3><h4 class="heading4" style="color: #B236A9" id="dépendances-nécessaires-17"><a class="anchor" href="#dépendances-nécessaires-17"><img src="../assets/anchor.svg" alt></a>Dépendances nécessaires</h4><img src="./assets/metrics-dependances.png">

<h4 class="heading4" style="color: #B236A9" id="activer-la-récupération-des-métriques"><a class="anchor" href="#activer-la-récupération-des-métriques"><img src="../assets/anchor.svg" alt></a>Activer la récupération des métriques</h4><p>Afin d’autoriser la récupération de métriques Micrometer par Vertx, on spécifie les <strong>VertxOptions</strong> nécessaires.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">Vertx vertx = Vertx.vertx(<span class="hljs-keyword">new</span> VertxOptions().setMetricsOptions(
  <span class="hljs-keyword">new</span> MicrometerMetricsOptions()
    .setPrometheusOptions(<span class="hljs-keyword">new</span> VertxPrometheusOptions()
    .setEnabled(<span class="hljs-keyword">true</span>))
    .setEnabled(<span class="hljs-keyword">true</span>))
  );</code></pre><h4 class="heading4" style="color: #B236A9" id="créer-la-route-dédiée-aux-métriques"><a class="anchor" href="#créer-la-route-dédiée-aux-métriques"><img src="../assets/anchor.svg" alt></a>Créer la route dédiée aux métriques</h4><p>La récupération des métriques peut se faire de diverses façons, la plus commune étant en appelant un endpoint dédié. Dans le cas où Prometheus est utilisé, le handler connecté à l’url <strong>/metrics</strong> sera un <strong>PrometheusScrapingHandler</strong>. Lors d’instanciation de cet handler, il est possible de spécifier le nom la <strong>MeterRegistry</strong> (objet auprès duquel les différentes sondes, appelées <strong>Meter</strong>, vont s’enregistrer). Si aucun nom n’est précisé, une registry par défaut sera créée.</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">router.route(<span class="hljs-string">&quot;/metrics&quot;</span>).handler(PrometheusScrapingHandler.create (<span class="hljs-string">&quot;user-metrics-registry&quot;</span>)) ;</code></pre><h4 class="heading4" style="color: #B236A9" id="référencement-et-utilisation-des-sondes"><a class="anchor" href="#référencement-et-utilisation-des-sondes"><img src="../assets/anchor.svg" alt></a>Référencement et utilisation des sondes</h4><p>Les sondes sont référencées dans une <strong>MeterRegistry</strong> accessible depuis presque n’importe où dans le code grâce à la classe <strong>BackendRegistries</strong>, sa méthode <strong>getNow</strong> pouvant prendre en paramètre le nom de la registry passé lors de la création du <strong>PrometheusScrapingHandler</strong>.
Il est tout à fait envisageable de référencer et utiliser des sondes depuis les handlers (par exemple pour comptabiliser le nombre d’appels à un endpoint sur un intervalle de temps donné).</p>
<pre style="background-color: #F6CDF3"><code class="code" style="color: #252A80">MeterRegistry reg = BackendRegistries.getNow(<span class="hljs-string">&quot;user-metrics-registry&quot;</span>); Counter counter = Counter.builder(<span class="hljs-string">&quot;user.api.number.calls&quot;</span>).regis- ter(reg);
<span class="hljs-comment">//...</span>
counter.increment();</code></pre></div>

                        <div class="h2-part" id="div-conclusion">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#conclusion"><img src="../assets/anchor.svg" alt></a>Conclusion</h2>

                            <div class="title-menu-container"><p class="title-menu" id="conclusion">Conclusion</p></div>
<p>Alors que faut il retenir de Vertx ? Simplement qu’il permet de développer rapidement des applications réactives offrant d’excellentes performances, mais en restant simple à appréhender.</p>
<p>En effet, quel que soit le framework ou toolkit, il n’a réellement d’intérêt que s’il est efficace et simple a utiliser. C’est une mission accomplie pour Vertx, qui a su en quelques années rassembler une importante communauté, mettre à disposition une documentation complète et parfaitement à jour, tout en fournissant régulièrement de nouvelles features très pratiques.</p>
<p>Soulignons enfin que Vertx fut également un des principaux composant employé
dans le développement de Quarkus, projet visant, entre autres, à remettre le langage Java dans la course à la performance.</p>
<p>Vertx est donc LE toolkit que tout developpeur Java devrait connaître, alors n’hésitez plus et lancez vous !</p>
</div>

                        <div class="h2-part" id="div-références">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#références"><img src="../assets/anchor.svg" alt></a>Références</h2>

                            <div class="title-menu-container"><p class="title-menu" id="références">Références</p></div>
<ul>
<li><a class="links" style="color :#B236A9" href="https://vertx.io/docs/" title="">https://vertx.io/docs/</a> - Documentation officielle</li>
<li><a class="links" style="color :#B236A9" href="https://vertx.io/blog/" title="">https://vertx.io/blog/</a> - Le blog Vertx</li>
<li><a class="links" style="color :#B236A9" href="https://senelda.com/blog/nodejs-vs-vertx-part2-detailed-investigation-2/" title="">https://senelda.com/blog/nodejs-vs-vertx-part2-detailed-investigation-2/</a> - Comparatif Vertx / Node JS</li>
<li><a class="links" style="color :#B236A9" href="https://quarkus.io/" title="">https://quarkus.io/</a> - Site officiel de Quarkus (projet s’appuyant en partie sur Vertx)</li>
<li><a class="links" style="color :#B236A9" href="https://vertx.io/blog/eclipse-vert-x-goes-native/" title="">https://vertx.io/blog/eclipse-vert-x-goes-native/</a> - Générer une image native d’un projet Vertx</li>
</ul>
</div>

                        <div class="h2-part" id="div-a-propos-dineat">

                            <h2 class="heading2" style="color: #B236A9"><a class="anchor" href="#a-propos-dineat"><img src="../assets/anchor.svg" alt></a>A propos d&#39;Ineat</h2>

                            <div class="title-menu-container"><p class="title-menu" id="a-propos-dineat">A propos d&#39;Ineat</p></div>
<p>Convaincu que l’innovation constitue la meilleure réponse aux évolutions de notre société, Ineat a pour vocation de guider et accompagner les entreprises dans leur processus de transformation digitale en les aidants à s’approprier les nouvelles technologies. </p>
<p>Ce guide a été écrit par <strong>Mathias Deremer-Accettone</strong></p>
<p>Version : V1.0.0</p>
<p>Date d’édition : Novembre 2019 </p>
<p>Impression : Pixartprinting</p>
<p><strong>Merci à nos relecteurs :</strong>
Emmanuel Peru, Ludovic Dussart, Mehdi Slimani, Lucas Declercq </p>
<p>La direction artistique et les illustrations sont l’œuvre d’<strong>Ineat Studio</strong></p>

        </div>
        <script defer src="../script/SceneCreator.js"></script>
    </body>
</html>
